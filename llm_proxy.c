#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <pthread.h>
#include <fcntl.h>
#include <errno.h>
//#include <curl/curl.h>
#include "/usr/include/x86_64-linux-gnu/curl/curl.h"

#include "include/os.h"

#ifdef __LINUX__
#include <sys/socket.h>
#include <sys/epoll.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#define __LIBCURL__ 1
#endif

#ifdef __WINDOWS__
#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#include <direct.h>
#include <io.h>
#include <ws2tcpip.h>
#pragma comment(lib, "Ws2_32.lib")
#endif

#define KB * 1024

#define CONFIG_FILE           "config.ini"
#define MAX_CONFIG_LINE       1024
#define MAXEVENTS             512
#define PANDA_PORT            8484
#define LOCALHOST             0x0100007F

#ifdef __LINUX__
#define EVENT_READ            EPOLLIN
#define EVENT_WRITE           EPOLLOUT
#endif

#ifdef __LINUX__
typedef int                   socket_t;
typedef int                   pipe_t;
typedef pthread_mutex_t       mutex_t;
typedef pthread_cond_t        condition_t;
typedef pthread_t             tid_t;
#define mutex_lock(mtx)       pthread_mutex_lock  (mtx)
#define mutex_unlock(mtx)     pthread_mutex_unlock(mtx)

struct eventloop {
	struct epoll_event *events;
	int                 epoll_fd;
	pipe_t              llm_proxy_stdin;
	pipe_t              llm_proxy_stdout;
};

#endif

#ifdef __WINDOWS__
typedef SOCKET                socket_t;
typedef HANDLE                pipe_t;
typedef HANDLE                tid_t;
#define SOCK_CLOEXEC          0
#define condition_t           HANDLE
#define mutex_t               CRITICAL_SECTION
#define in_addr_t             struct in_addr


struct eventloop {
	HANDLE       iocp;
	pipe_t       llm_proxy_stdin;
	pipe_t       llm_proxy_stdout;
};

#endif

struct thread;
struct query;

typedef int                   event_fd_t;
typedef unsigned int          uint32_t;
typedef struct eventloop      eventloop_t;

typedef void (*token_handler_f)(struct query *query);

void           discord_token_handler (struct query *query);
int            net_tcp_connect       (const char *dst_addr, unsigned short dst_port);
char          *curl_get              (char *url);
eventloop_t   *eventloop_create      (pipe_t stdout_pipe);
void           llm_add_query         (struct query *query);

char          *index_html;
int            index_html_size;
unsigned char *travelpanda_png;
unsigned int   travelpanda_png_size;
unsigned char *lawpanda_png;
unsigned int   lawpanda_png_size;
unsigned char *drpanda_png;
unsigned int   drpanda_png_size;

struct config {
	char          *model;               // model filename
	char          *model_directory;     // directory containing model files
	char          *url;                 // where to find the model online
	unsigned short panda_port;          // localhost port for the discord bot to connect to
	unsigned short llm_port_start;      // llamacpp server --port (llm_port_start +1 for each instance)
	int            nr_model_instances;  // number of models to run
	int            nr_gpu_layers;       // --n-gpu-layers (llamacpp)
	int            ctx_size;            // --ctx-size     (llamacpp)
	int            use_pipes;           // use pipes or connect to llamacpp http server
	int            timeout;             // maximum amount of time to generate tokens for one question
	double         top_p;               // --top_p        (llamacpp)
};

static struct config config;

#define MAX_MODELS 1024

struct model {
	char          *name;                  // GGUF filename
	char          *type;                  // code | medical | law
	char          *org;                   // creator of model
	char          *status;                // downloaded ?
	char          *url;                   // huggingface URL of model
	int            nr_votes;
};

struct model      **models;
int                 nr_models;
char               *models_json;
int                 models_json_size;

struct query {
	char            *question;
	char            *id;              // question ID (used by discord.js to lookup the message object)
	char            *tokens;          // tokens generated by the LLM
	int              tokens_size;
	int              max_tokens_size;
	int              output_fd;       // the socket that panda.js is connected to - used to write() the tokens to
	int              output;          // socket output or -1 for only storing the tokens into a buffer
	mutex_t          query_lock;      // lock for synchronizing access to the query->tokens buffer
	token_handler_f  token_handler;   // function that sends tokens to either discord or an internal buffer (for WWW)
};

typedef struct query query_t;

struct thread {
	condition_t      qwait_condition; // thread will wait until a question is asked
	mutex_t          qwait_mutex;     // mutex for the wait condition (CRITICAL_SECTION on windows, pthread_cond_t on linux)
	eventloop_t     *eventloop;       // eventloop to manage the stdout descriptor of this thread's llama.cpp instance
	tid_t            tid;             // thread id
	char            *model;           // the model associated with this LLM instance
	char            *driver;          // llamacpp
	struct query    *query;           // user's question
	char           **usernames;       // keep track of usernames and assign a user to a single thread so that they keep the same context
	int              nr_users;        // number of usernames assigned to this chat model context
	int              busy;            // currently generating tokens for a specific question
	unsigned short   llm_port;        // llamacpp server port
};

static struct thread **threads;
mutex_t                thread_mutex;

#define HTTP_GET   "HTTP/1.1 200 OK\r\n"                 \
                   "Connection:close\r\n"                \
                   "Content-Type:text/html\r\n"          \
                   "Content-Length: %d\r\n\r\n"          \


#define HTTP_IMAGE "HTTP/1.1 200 OK\r\n"                 \
                   "Content-Type:image/png\r\n"          \
                   "Connection: close\r\n"               \
                   "Content-Length: %d\r\n\r\n"          \

#define HTTP_JSON "HTTP/1.1 200 OK\r\n"                  \
                  "Content-type: application/json\r\n"   \
                  "Content-Length: %d\r\n\r\n"           \

#define LLM_OUTPUT_DISCORD 1

void *zmalloc(long size)
{
	void *ptr;

	if (size <= 0)
		return NULL;	
	ptr = (void *)malloc(size);
	if (!ptr)
		return NULL;
	memset(ptr, 0, size);
	return (ptr);
}

int cstring_line_count(char *str)
{
	char *line, *p;
	int   count = 0;

	line = str;
	while ((p=strchr(line, '\n'))) {
		count++;
		line = p+1;
	}
	return count;
}

#ifdef __WINDOWS__
/* threads/synchronization */
void llm_thread_create(void *(*func)(void *), struct thread *thread)
{
	thread->qwait_condition = CreateEvent(NULL, TRUE, FALSE, NULL);
	InitializeCriticalSection(&thread->qwait_mutex);
	thread->tid = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)func, thread, 0, NULL);
}

void thread_create(void *(*func)(void *), void *args)
{
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)func, args, 0, NULL);
}

void mutex_lock(mutex_t *mtx)
{
	EnterCriticalSection(mtx);
}

void mutex_unlock(mutex_t *mtx)
{
	LeaveCriticalSection(mtx);
}

/* networking */
void net_socket_block(socket_t sockfd)
{
	DWORD nb = 1;
	ioctlsocket(sockfd, FIONBIO, &nb);
}

void net_socket_nonblock(socket_t sockfd)
{
	DWORD nb = 0;
	ioctlsocket(sockfd, FIONBIO, &nb);
}

void printError()
{
	DWORD lastError = GetLastError();
	LPSTR errorMessage;
	DWORD requiredBufferSize = FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM, NULL, lastError, MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT), (LPSTR)&errorMessage, 0, NULL);
	errorMessage = (LPSTR) malloc(requiredBufferSize+100);
	FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, lastError, MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT), (LPSTR)&errorMessage, 0, NULL);
//	free(errorMessage);
	printf("%s\n", errorMessage);
}

void thread_wait(struct thread *thread)
{
	DWORD wait_result = WaitForSingleObject(thread->qwait_condition, INFINITE);
	if (wait_result != WAIT_OBJECT_0) {
		printError();
		exit(-1);
	}
}

void thread_signal(struct thread *thread)
{
	EnterCriticalSection(&thread->qwait_mutex);
	SetEvent(thread->qwait_condition);
	LeaveCriticalSection(&thread->qwait_mutex);
}

void write_pipe(pipe_t stdin_pipe, char *question)
{
	DWORD dwWritten;

	WriteFile(stdin_pipe, question, strlen(question), &dwWritten, NULL);
}

void llm_network_proxy(struct thread *thread)
{

}

void llm_pipe_proxy(struct thread *thread)
{
    STARTUPINFO         start_info = { sizeof(start_info) };
    PROCESS_INFORMATION process_info;
	SECURITY_ATTRIBUTES saAttr;
	pipe_t              stdin_READ  = NULL,  stdin_WRITE = NULL;
	pipe_t              stdout_READ = NULL, stdout_WRITE = NULL;
	char                cmdLine[256];

	saAttr.nLength              = sizeof(SECURITY_ATTRIBUTES); 
	saAttr.bInheritHandle       = TRUE; 
	saAttr.lpSecurityDescriptor = NULL; 

	// Create a pipe for the child process's STDIN
	if (!CreatePipe(&stdin_READ, &stdin_WRITE, &saAttr, 0))
		exit(-1);

	// Create a pipe for the child process's STDOUT
	if (!CreatePipe(&stdout_READ, &stdout_WRITE, &saAttr, 0))
		exit(-1);

	// Ensure the write handle to the pipe for STDIN is not inherited.  
	if (!SetHandleInformation(stdin_WRITE, HANDLE_FLAG_INHERIT, 0))
		exit(-1);

	// Ensure the read handle to the pipe for STDOUT is not inherited
	if (!SetHandleInformation(stdout_READ, HANDLE_FLAG_INHERIT, 0))
		exit(-1);

	// Create a STARTUPINFO struct and set the standard output to stdout_WRITE and stdin to stdin_READ
	ZeroMemory(&start_info, sizeof(STARTUPINFO));
	start_info.cb         = sizeof(STARTUPINFO); 
	start_info.hStdError  = stdout_READ;
	start_info.hStdOutput = stdout_READ;
	start_info.hStdInput  = stdin_WRITE;
	start_info.dwFlags   |= STARTF_USESTDHANDLES;

	// keep track of main.exe's STDIN/STDOUT
	thread->eventloop     = eventloop_create(stdin_WRITE);
	thread->eventloop->llm_proxy_stdin  = stdout_READ;
	thread->eventloop->llm_proxy_stdout = stdin_WRITE;

    // Create a new process that reads from the pipe and writes to the standard output
	snprintf(cmdLine, sizeof(cmdLine)-1, "main.exe --interactive-first --n-gpu-layers 15000 -m %s", config.model);
	if (!CreateProcessA("c:\\ai\\llamacpp\\main.exe", cmdLine, NULL, NULL, TRUE, 0, NULL, NULL, &start_info, &process_info)) {
		printf("failed to create process\n");
		exit(-1);
	}

	CloseHandle(stdout_WRITE);
	CloseHandle(stdin_READ);
}

eventloop_t *eventloop_create(pipe_t stdin_pipe)
{
	eventloop_t *eventloop = (eventloop_t *)zmalloc(sizeof(*eventloop));
	return (eventloop);
}

void process_llm_tokens(struct thread *thread, pipe_t llm_proxy_stdout)
{
	struct query *query = thread->query;
	char          token[8192];
	DWORD         size, bytesRead;

/*	while (PeekNamedPipe(llm_proxy_stdout, NULL, 0, NULL, &size, NULL)) {
		if (size == 0) {
			Sleep(500);
			continue;
		}*/
		ReadFile(llm_proxy_stdout, token, size, &bytesRead, NULL);		
		printError();
		printf("token: %s bytesRead: %d\n", token, bytesRead);

//		if (!token)
//			continue;
		if (query->tokens_size + bytesRead >= query->max_tokens_size) {
			query->max_tokens_size *= 2;
			query->tokens = (char *)realloc(query->tokens, query->max_tokens_size);
			if (!query->tokens)
				exit(-1);
		}
		memcpy(query->tokens+query->tokens_size, token, bytesRead);
		query->tokens[query->tokens_size] = 0;
		if (strlen(query->tokens) >= 64)
			discord_token_handler(query);
//	}
}

void init_os()
{
	WSADATA wsaData;
	WORD    versionRequested = MAKEWORD(2, 2);
	WSAStartup(versionRequested, &wsaData);

	InitializeCriticalSection(&thread_mutex);
}
#endif

#ifdef __LINUX__
void event_mod(int epoll_fd, int event_type, int fd)
{
	struct epoll_event event;
	event.events   = event_type;
	event.data.ptr = NULL;
	epoll_ctl(epoll_fd, EPOLL_CTL_MOD, fd, &event);
}

void event_add(int epoll_fd, int event_type, int fd)
{
	struct epoll_event event;
	event.events   = event_type;
	event.data.ptr = NULL;
	epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &event);
}

void event_del(int epoll_fd, int event_type, int fd)
{
	struct epoll_event event;
	event.events   = event_type;
	event.data.ptr = NULL;
	epoll_ctl(epoll_fd, EPOLL_CTL_DEL, fd, &event);
}

void net_socket_nonblock(socket_t sockfd)
{
	int val = fcntl(sockfd, F_GETFL);
	fcntl(sockfd, F_SETFL, val|O_NONBLOCK);
}

void thread_wait(struct thread *thread)
{
	mutex_lock(&thread->qwait_mutex);
	pthread_cond_wait(&thread->qwait_condition, &thread->qwait_mutex);
}

/* Wake up thread driving llamacpp's main.exe */
void thread_signal(struct thread *thread)
{
	pthread_cond_signal(&thread->qwait_condition);
}

void llm_thread_create(void *(*func)(void *), struct thread *thread)
{
	pthread_create(&thread->tid, NULL, func, thread);
	memset(&thread->qwait_condition, 0, sizeof(thread->qwait_condition));
	memset(&thread->qwait_mutex,     0, sizeof(thread->qwait_mutex));
	pthread_detach(thread->tid);
}

void thread_create(void *(*func)(void *), void *args)
{
	pthread_t tid;
	pthread_create(&tid, NULL, func, args);
	pthread_detach(tid);
}

void write_pipe(pipe_t stdin_pipe, char *question)
{
	write(stdin_pipe, question, strlen(question));
}

#define LLM_PROMPT	"POST /completion HTTP/1.1\r\n"  \
					"Connection: Keep-alive\r\n\r\n" \
					"{\"stream\":true,\"stop\":[\"</s>\",\"Llama:\",\"User:\"]},\"prompt\":\"%s\"}"
				
//{"stream":true,"n_predict":400,"temperature":0.7,"stop":["</s>","Llama:","User:"],"repeat_last_n":256,"repeat_penalty":1.18,"top_k":40,"top_p":0.95,"min_p":0.05,"tfs_z":1,"typical_p":1,"presence_penalty":0,"frequency_penalty":0,"mirostat":0,"mirostat_tau":5,"mirostat_eta":0.1,"grammar":"","n_probs":0,"image_data":[],"cache_prompt":true,"api_key":"","slot_id":-1,"prompt":"This is a conversation between User and Llama, a friendly chatbot. Llama is helpful, kind, honest, good at writing, and never fails to answer any requests immediately and with precision.\n\nUser: what is your name?\nLlama:"}
					

void llm_ask_question(struct thread *thread, char *question)
{
	if (config.use_pipes) {
		write(thread->eventloop->llm_proxy_stdin, question, strlen(question));
		return;
	}

	char  request[1024 KB];
	char *response;

	snprintf(request, sizeof(request)-1, LLM_PROMPT, question);
	if (!(response=curl_get(request)))
		return;
}

void llm_network_proxy(struct thread *thread)
{
	char              *argv[] = { "/usr/src/ai/llama.cpp/server",  "--log-disable", "-m", "/usr/src/ai/llama.cpp/openhermes-2.5-mistral-7b.Q4_K_M.gguf", "--port", NULL, NULL };
	const char        *envp[] = { "PATH=$PATH:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin", NULL };
	char               portarg[8];
	pipe_t             llm_proxy_sockfd;

	// --port
	snprintf(portarg, sizeof(portarg)-1, "%d", thread->llm_port);
	argv[5] = portarg;

	switch (fork()) {
		case -1:
			exit(-1);
		case 0:
			execve(argv[0], argv, (char **)envp);
			exit(-1);
		default:
			break;
	}
	sleep(3);
	llm_proxy_sockfd  = net_tcp_connect("127.0.0.1", thread->llm_port);
	thread->eventloop = eventloop_create(llm_proxy_sockfd);
	thread->eventloop->llm_proxy_stdin = thread->eventloop->llm_proxy_stdout = llm_proxy_sockfd;
	if (llm_proxy_sockfd == -1)
		exit(-1);
}	

void llm_pipe_proxy(struct thread *thread)
{
	eventloop_t       *eventloop;
	char              *argv[]    = { "/usr/src/ai/llama.cpp/main",  "--log-disable", "-m", "/usr/src/ai/llama.cpp/openhermes-2.5-mistral-7b.Q4_K_M.gguf", "--interactive-first", NULL };
	const char        *envp[]    = { "PATH=$PATH:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin", NULL };
	char               buf[512];
	int                pipe1[2]; // the pipe between the parent and the child's STDIN
	int                pipe2[2]; // the pipe between the parent and the child's STDOUT

	// Create two pipes for standard input and output of the child process
	if (pipe(pipe1) < 0 || pipe(pipe2) < 0)
		exit(-1);

	/*
	 * child  reads from pipe1[0], parent writes to pipe1[1]
	 * parent reads from pipe2[0], child  writes to pipe2[1]
	 */
	switch (fork()) {
		case -1:
			exit(-1);
		case 0:
			/* Replace stdin with the read end of pipe1 and replace stdout with the write end of pipe2 */
			close(pipe1[1]);
			dup2(pipe1[0], STDIN_FILENO);
			close(pipe1[0]);
			close(pipe2[0]);
			dup2(pipe2[1], STDOUT_FILENO);
	        close(pipe2[1]);
			execve(argv[0], argv, (char **)envp);
			exit(-1);
		default:
			thread->eventloop                   = eventloop_create(pipe2[0]);
			thread->eventloop->llm_proxy_stdin  = pipe1[0]; // child's stdin  (write questions to stdin)
			thread->eventloop->llm_proxy_stdout = pipe2[0]; // child's stdout (get answers/tokens from stdout)
			break;
	}
}

void process_llm_tokens(struct thread *thread, pipe_t llm_proxy_stdout)
{
	eventloop_t        *eventloop = thread->eventloop;
	query_t            *query     = thread->query;
	struct epoll_event *event;
	char                token[8192];
	int                 nr_events, nbytes, fd;

	while (1) {
		nr_events = epoll_wait(thread->eventloop->epoll_fd, thread->eventloop->events, MAXEVENTS, -1);
		for (int x = 0; x<nr_events; x++) {
			event = &eventloop->events[x];
			if (event->events & EPOLLIN) {
				/*
				 * llama.cpp is writing tokens to its stdout, read the tokens and send them to the discord bot or a memory buffer
				 */
				nbytes = read(llm_proxy_stdout, token, 256);
				if (nbytes <= 0)
					continue;

				if (query->tokens_size + nbytes >= query->max_tokens_size) {
					query->max_tokens_size *= 2;
					query->tokens = realloc(query->tokens, query->max_tokens_size);
					if (!query->tokens)
						exit(-1);
				}

				// update query->tokens with the latest 'tokens' read() from llamacpp's stdout
				mutex_lock(&query->query_lock);
				memcpy(query->tokens+query->tokens_size, token, nbytes);
				query->tokens_size += nbytes;
				query->tokens[query->tokens_size] = 0;
				mutex_unlock(&query->query_lock);

				if (query->token_handler && strlen(query->tokens) > 64)
					query->token_handler(query);
			} else if (event->events & EPOLLRDHUP) {
				close(event->data.fd);
				break;
			}
		}
	}
}

eventloop_t *eventloop_create(pipe_t stdout_pipe)
{
	struct epoll_event *events;
	eventloop_t        *eventloop = (eventloop_t *)zmalloc(sizeof(*eventloop));

	eventloop->epoll_fd = epoll_create1(EPOLL_CLOEXEC);
	eventloop->events   = (struct epoll_event *)malloc(sizeof(*events) * MAXEVENTS);
	event_add(eventloop->epoll_fd, EVENT_READ, stdout_pipe);
	return (eventloop);	
}

void init_os()
{

}
#endif

#ifdef __LIBCURL__
struct curldata {
    char         *memory;
    size_t        size;
	size_t        max_size;
};

size_t curl_get_data(char *buf, size_t size, size_t count, void *data)
{
	struct curldata *cdata = (struct curldata *)data;
	char *ptr;
	size_t realsize = size*count;

	ptr = (char *)realloc(cdata->memory, cdata->size + realsize + 1);
	if (!ptr)
		return 0;
	cdata->memory = ptr;
	memcpy(&(cdata->memory[cdata->size]), buf, realsize);
	cdata->size += realsize;
	cdata->memory[cdata->size] = 0;
	return (realsize);
}

char *curl_get(char *url)
{
	CURL              *curl;
	struct curldata    cdata;
	struct curl_slist *headers = NULL;
	int                respones_len;

	cdata.memory   = (char *)malloc(1000 KB);
	cdata.size     = 0;
	cdata.max_size = 1000 KB;
	if (!cdata.memory)
		return NULL;

	headers = curl_slist_append(headers, "Accept-Encoding: gzip");
	curl    = curl_easy_init();
	curl_easy_setopt(curl, CURLOPT_URL, url);
	curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, curl_get_data);
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, &cdata);
	curl_easy_setopt(curl, CURLOPT_SSLENGINE_DEFAULT, 1L);
	curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0);
	curl_easy_setopt(curl, CURLOPT_TIMEOUT, 3);
	curl_easy_setopt(curl, CURLOPT_VERBOSE, 1);
	curl_easy_perform(curl);
	printf("mem: %s\n", cdata.memory);
	curl_easy_cleanup(curl);
	curl_slist_free_all(headers);
	return (cdata.memory);
out:
	curl_easy_cleanup(curl);
	curl_slist_free_all(headers);
	free(cdata.memory);
	return (NULL);
}
#endif

socket_t net_tcp_bind(uint32_t bind_addr, unsigned short port)
{
	struct sockaddr_in serv;
	int sockfd, val = 1;

	sockfd = socket(AF_INET, SOCK_STREAM|SOCK_CLOEXEC, IPPROTO_TCP);
	if (sockfd < 0)
		return -1;

	setsockopt(sockfd, SOL_SOCKET,  SO_REUSEADDR, (const char *)&val, sizeof(val));
	setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY,  (const char *)&val, sizeof(val));

	serv.sin_family      = AF_INET;
	serv.sin_port        = htons(port);
	serv.sin_addr.s_addr = bind_addr;
	if (bind(sockfd, (struct sockaddr *)&serv, 0x10) < 0) {
		close(sockfd);
		return -1;
	}
	if (listen(sockfd, 15) < 0) {
		close(sockfd);
		return -1;
	}
	return (sockfd);
}

int net_tcp_connect(const char *dst_addr, unsigned short dst_port)
{
	struct sockaddr_in paddr;
	int dst_fd;

	dst_fd = socket(AF_INET, SOCK_STREAM|SOCK_CLOEXEC, IPPROTO_TCP);
	if (dst_fd < 0) {
		perror("socket");
		return -1;
	}
	paddr.sin_family      = AF_INET;
	paddr.sin_port        = htons(dst_port);
	paddr.sin_addr.s_addr = inet_addr(dst_addr);
	if (connect(dst_fd, (struct sockaddr *)&paddr, 0x10) < 0) {
		close(dst_fd);
		return -1;
	}
	return (dst_fd);
}

void net_download_model(char *modelname)
{


}

void http_ask_question(int fd, char *request)
{
	struct query *query;
	char         *p = strstr(request, "prompt:");

	if (!p)
		return;

	query                = (struct query *)malloc(sizeof(*query));
	query->output_fd     = -1;
	query->token_handler = NULL;
	llm_add_query(query);
}

void http_set_model(int fd, char *request)
{


}

void http_send_img(int fd, char *request)
{
	// GET /img/drpanda.png HTTP/1.1\r\n
	char *image = request+9;

	if (!strncmp(image, "drpanda", 7))
		send(fd, drpanda_png, drpanda_png_size, 0);
	else if (!strncmp(image, "lawpanda", 8))
		send(fd, lawpanda_png, lawpanda_png_size, 0);
	else if (!strncmp(image, "travelpanda", 11))
		send(fd, travelpanda_png, travelpanda_png_size, 0);
}

int model_present(char *modelname)
{
	struct stat sb;
	char        path[256];

	snprintf(path, sizeof(path)-1, "%s/%s", config.model_directory, modelname);
	if (stat(path, &sb) == -1)
		return 0;
	return 1;
}

void load_models()
{
	struct stat   sb;
	struct model *model;
	char          buf[1024 KB];
	char         *line, *nextline, *type, *url, *json;
	int           fd, json_size = 0, max_json_size = 4096;

	fd = open("models.csv", O_RDONLY);
	if (fd < 0)
		exit(-1);
	if (fstat(fd, &sb) == -1 || sb.st_size >= sizeof(buf))
		exit(-1);
	if (read(fd, buf, sb.st_size) <= 0)
		exit(-1);
	buf[sb.st_size] = 0;

	nr_models = cstring_line_count(buf);
	models    = (struct model **)malloc(sizeof(void *) * nr_models);
	if (!models)
		exit(-1);

	line = buf;
	json = (char *)malloc(max_json_size);
	if (!json)
		exit(-1);
	json[json_size++] = '[';
	while ((nextline=strchr(line, '\n'))) {
		// modelname,type,url
		type = strchr(line, ',');
		if (!type) {
			printf("incorrect models.csv format: modelname,type,url\n");
			line = nextline + 1;
			continue;
		}
		url  = strchr(type, ',');
		if (!url) {
			printf("incorrect models.csv format: modelname,type,url\n");
			line = nextline + 1;
			continue;
		}

		*nextline++         = 0;
		*type++             = 0;

		model               = zmalloc(sizeof(*model));
		model->name         = strdup(line);
		model->type         = strdup(type);
		model->url          = strdup(url);
		models[nr_models++] = model;

		if (model_present(model->name))
			model->status   = "downloaded";
		else
			model->status   = "not installed";

		json_size += snprintf(json+json_size, 256, "{\"model\":\"%s\",\"type\":\"%s\",\"status\":\"%s\"}", model->name, model->type, model->status);
		if (nr_models >= MAX_MODELS)
			break;
		line = nextline;
		if (json_size + 300 >= max_json_size) {
			max_json_size *= 2;
			json = realloc(json, max_json_size);
			if (!json)
				exit(-1);
		}
	}
	json[json_size++] = ']';
	models_json = (char *)malloc(sizeof(HTTP_JSON)+json_size+256);
	if (!models_json)
		exit(-1);
	models_json_size  = snprintf(models_json, 128, HTTP_JSON, json_size);
	memcpy(models_json+models_json_size, json, json_size);
	models_json_size += json_size;
	free(json);
}

void http_send_models(int fd)
{
	printf("models json: %s\n", models_json);
	send(fd, models_json, models_json_size, 0);
}

void *http_server(void *args)
{
	struct sockaddr_in srv, cli;
	char               buf[1024];
	char              *mainpage;
	socklen_t          slen   = 16;
	int                val    = 1, sockfd, client_fd, nbytes, mainpage_size;
	unsigned short     port   = 8086;

	mainpage      = (char *)malloc(sizeof(HTTP_GET)+index_html_size+256);
	mainpage_size = snprintf(mainpage, 128, HTTP_GET, index_html_size);
	memcpy(mainpage+mainpage_size, index_html, index_html_size);
	mainpage_size += index_html_size;

	sockfd = net_tcp_bind(LOCALHOST, port);
	if (sockfd == -1)
		exit(-1);
	for (;;) {
		client_fd = accept(sockfd, (struct sockaddr *)&cli, &slen);
		if (client_fd < 0)
			continue;
		nbytes = recv(client_fd, buf, 1024, 0);
		if (nbytes <= 0) {
			close(client_fd);
			continue;
		}
		buf[nbytes] = 0;
		if (!strncmp(buf, "GET ", 4)) {
			if (strstr(buf, "GET /index.html HTTP/1.1")) {
				send(client_fd, mainpage, mainpage_size, 0);
			} else if (strstr(buf, "/set_model/")) {
				// assign model to an LLM slot
				http_set_model(client_fd, buf);
			} else if (strstr(buf, "/img")) {
				http_send_img(client_fd, buf);
			} else if (strstr(buf, "/models"))
				http_send_models(client_fd);
		} else if (!strncmp(buf, "POST ", 5)) {
			if (strstr(buf, "/prompt/")) {
				http_ask_question(client_fd, buf);
			}
		}
		close(client_fd);
	}
}

void load_image(const char *filename, unsigned char **image, unsigned int *image_size)
{
	struct stat sb;
	char       *buf;
	int         fd, nbytes;

	fd = open(filename, O_RDONLY);
	if (fd <= 0)
		return;
	fstat(fd, &sb);
	buf = malloc(sb.st_size + sizeof(HTTP_IMAGE)+512);
	if (!buf)
		return;
	nbytes = snprintf(buf, 256, HTTP_IMAGE, (int)sb.st_size);
	read(fd, buf+nbytes, sb.st_size);
	close(fd);
	*image_size = sb.st_size+nbytes;
	*image      = buf;
}

void load_html() {
	struct stat sb;
	int fd, nbytes;

	fd = open("index.html", O_RDONLY);
	if (fd <= 0)
		exit(-1);
	fstat(fd, &sb);
	index_html_size = sb.st_size;
	index_html      = (char *)malloc(index_html_size);
	nbytes          = read(fd, index_html, index_html_size);
	if (nbytes != index_html_size)
		exit(-1);
}

void init_http()
{
	load_html();
	load_image("drpanda.png",     &drpanda_png,     &drpanda_png_size);
	load_image("lawpanda.png",    &lawpanda_png,    &lawpanda_png_size);
	load_image("travelpanda.png", &travelpanda_png, &travelpanda_png_size);	
	thread_create(http_server, NULL);
}

void load_config() {
    FILE *config_file = fopen(CONFIG_FILE, "r");
    if (!config_file) {
        perror("Failed to open config.ini");
        exit(EXIT_FAILURE);
    }

    char line[MAX_CONFIG_LINE];
    while (fgets(line, sizeof(line), config_file)) {
        char *key = strtok(line, "=");
        char *value = strtok(NULL, "\n");

        if (key && value) {
            if (strcmp(key, "nr_model_instances") == 0) {
                config.nr_model_instances = atoi(value);
            } else if (strcmp(key, "panda_port") == 0) {
                config.panda_port = atoi(value);
            } else if (strcmp(key, "model") == 0) {
                config.model = strdup(value);
            } else if (strcmp(key, "timeout") == 0) {
				config.timeout = atoi(value);
			} else if (strcmp(key, "use_pipes") == 0) {
				config.use_pipes = atoi(value);
			} else if (strcmp(key, "llm_port_start") == 0) {
				config.llm_port_start = atoi(value);
			} else if (strcmp(key, "model_directory") == 0) {
				config.model_directory = strdup(value);
			}
        }
    }
    fclose(config_file);
}

void cleanup() {
	for (int x = 0; x < config.nr_model_instances; x++) {
		free(threads[x]);
	}
	free(threads);
}

void discord_token_handler(struct query *query)
{
	char msg[2048];
	int  msg_size;

	msg_size = snprintf(msg, sizeof(msg)-1, "%s %s", query->id, query->tokens);
	send(query->output_fd, msg, msg_size, 0);
	query->tokens_size = 0;
	memset(query->tokens, 0, query->tokens_size);
}

void *llm_proxy_thread(void *args)
{
	struct thread      *thread    = (struct thread *)args;
	struct timeval      timeout;
	eventloop_t        *eventloop = thread->eventloop;
	fd_set              rdset;
	char                chatbuf[4096];
	char                tokenbuf[1024];
	char               *token;
	int                 nr_events, nready, fd, nbytes;

	/* 
	 * fork/execve llama.cpp/main and wait for questions from panda.js which will be written to the child's stdin
	 * llm_proxy_stdout is the child's standard output and select() will be used to monitor when tokens are being written to it
	 */
	if (config.use_pipes != 0)
		llm_pipe_proxy(thread);
	else
		llm_network_proxy(thread);

	while (1) {
		/*
		 * Wait for new questions from panda.js (via main())
		 */

		thread->busy = 0;
		thread_wait(thread);

		/* write the question to llamacpp's standard input */
		write_pipe(eventloop->llm_proxy_stdin, thread->query->question);
		process_llm_tokens(thread, eventloop->llm_proxy_stdout);
	}
}

struct query *new_query(char *question)
{
	struct query *query = (struct query *)malloc(sizeof(*query));
	char         *p     = strchr(question, ' ');

	if (!p)
		return NULL;
	*p++ = 0;

	query->question        = strdup(p);
	query->id              = strdup(question);
	query->tokens          = (char *)malloc(8192);
	query->tokens_size     = 0;
	query->max_tokens_size = 8192;
	return (query);
}

void llm_add_query(struct query *query)
{
	mutex_lock(&thread_mutex);
	for (int x = 0; x<config.nr_model_instances; x++) {
		if (!threads[x]->busy) {
			threads[x]->busy  = 1;
			threads[x]->query = query;
			switch (query->output) {
				case LLM_OUTPUT_DISCORD:
					query->token_handler = discord_token_handler;
					break;
			}
			thread_signal(threads[x]);
			break;
		}
	}
	mutex_unlock(&thread_mutex);
}


int main()
{
	struct sockaddr_in  client_addr;
	struct thread      *thread;
	struct query       *query;
	char                question_buf[4096];
	int                 panda_server_fd, client_fd, nbytes, client_addr_len, nr_threads;

	load_models();
	init_http();
	init_os();
	load_config();
	printf("nr models: %d\n", config.nr_model_instances);
	printf("port: %d\n",      config.panda_port);
	printf("model: %s\n",     config.model);

	nr_threads = config.nr_model_instances;
	threads    = (struct thread **)malloc(sizeof(struct thread) * nr_threads);

	for (int x = 0; x<nr_threads; x++) {
		thread           = (struct thread *)zmalloc(sizeof(*thread));
		threads[x]       = thread;
		thread->llm_port = config.llm_port_start++;
		llm_thread_create(llm_proxy_thread, thread);
	}

	panda_server_fd = net_tcp_bind(inet_addr("127.0.0.1"), config.panda_port);
	while (1) {
		client_fd = accept(panda_server_fd, (struct sockaddr *)&client_addr, &client_addr_len);
		if (client_fd == -1 && errno == EINTR)
			continue;
		while (1) {
			nbytes = recv(client_fd, question_buf, sizeof(question_buf)-1, 0);
			if (nbytes <= 0)
				break;
			query = new_query(question_buf);
			if (!query)
				continue;

			/*
			 * Add query to a thread that manages an LLM which isn't busy
			 */
			query->output_fd = client_fd;
			query->output    = LLM_OUTPUT_DISCORD;
			llm_add_query(query);
		}
		close(client_fd);
	}
}
